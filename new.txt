from collections import defaultdict
from bitarray import bitarray
import os

# ============================================================
# Utility functions and constants
# ============================================================

def inner_dict():
    return defaultdict(int)


TOTAL_BITS = 32
MAX_RANGE = (1 << TOTAL_BITS) - 1
HALF = 1 << (TOTAL_BITS - 1)
QUARTER = HALF >> 1
MASK = MAX_RANGE - 1
ESC = 256


# ============================================================
# Arithmetic Coder Class
# ============================================================

class ArithmeticCoder:

    def __init__(self, order=4):
        self.order = order

        # Range and bit counters
        self.low = 0
        self.high = MASK
        self.bitqueue = 0
        self.output_len = 0

        # I/O streams
        self.output = bitarray()
        self.input_stream = bitarray()
        self.output_stream = 0
        self.index = 0
        self.end = False
        self.code = 0

        # Context models
        self.contexts = defaultdict(inner_dict)
        self.order_minus1 = defaultdict(int)
        for i in range(257):  # 0..256 (including ESC)
            # order -1: symbol frequencies = 1 (uniform). store cumulative-like values if needed
            self.order_minus1[bytes([i % 256])] = 1  # keep simple uniform counts

        # History buffer
        self.history = b''
        self.total = 0

    # ========================================================
    # Core arithmetic coding operations
    # ========================================================

    def make_cumulative(self, ctx):
        """
        Return cumulative mapping symbol -> cumulative_low (starting at 0),
        consistent between encoder and decoder because both use the same contexts dict.
        """
        new_freqs = {}
        freqs = self.contexts.get(ctx, {})
        temp = 0
        for key, f in freqs.items():
            new_freqs[key] = temp
            temp += f
        # Also add ESC if present (make sure ESC has a cumulative entry if in freqs)
        if ESC in freqs and ESC not in new_freqs:
            new_freqs[ESC] = temp
            temp += freqs[ESC]
        return new_freqs

    def output_bit(self, bit):
        # bit is False/True or 0/1
        b = 1 if bit else 0
        self.output.append(bool(b))
        self.output_len += 1

        # flush stored opposite bits for underflow
        while self.bitqueue > 0:
            # append inverted bit
            self.output.append(bool(1 - b))
            self.bitqueue -= 1
            self.output_len += 1

    # ========================================================
    # Encoding operations
    # ========================================================

    def update(self, ctx, symbol, order_minus1=False):
        """
        Update ranges and output bits as needed for the provided symbol within ctx.
        If order_minus1 is True, use the fixed order-(-1) model.
        """
        if not order_minus1:
            freqs_cum = self.make_cumulative(ctx)
            temp = self.contexts[ctx][symbol]
            total = sum(self.contexts[ctx].values())
            l = freqs_cum.get(symbol, 0)
            h = l + temp
        else:
            # order -1: uniform 1..256 plus ESC = 1 => total 257
            freqs_cum = None
            temp = 1
            total = 257
            # for order-1 cumulative we treat symbol value as its index [0..255]
            # compute cumulative `l` = symbol value, h = l + 1
            l = symbol[0] if isinstance(symbol, (bytes, bytearray)) else symbol
            h = l + 1

        rng = self.high - self.low + 1

        if total == 0:
            self.high = self.low + rng - 1
        else:
            # update high/low according to standard arithmetic coding formulas
            self.high = self.low + (h * rng) // total - 1
            self.low = self.low + (l * rng) // total

        # renormalize and output bits
        while True:
            if self.high < HALF:
                # MSB = 0
                self.output_bit(False)

            elif self.low >= HALF:
                # MSB = 1
                self.output_bit(True)
                self.low -= HALF
                self.high -= HALF

            elif QUARTER <= self.low and self.high < 3 * QUARTER:
                # Underflow (E3), count it and shift range
                self.low -= QUARTER
                self.high -= QUARTER
                self.bitqueue += 1

            else:
                break

            # shift left one bit
            self.low <<= 1
            self.high = (self.high << 1) | 1
            # keep within mask
            self.low &= MAX_RANGE
            self.high &= MAX_RANGE

    def encode(self, input_stream, length):
        """
        input_stream: a file-like object opened in 'rb' mode
        length: number of bytes to read from input_stream
        returns: bitarray of encoded bits
        """
        self.high = MAX_RANGE
        self.low = 0
        self.message_len = length
        self.total = 0
        self.history = b''
        self.output.clear()
        self.bitqueue = 0

        while True:
            if length <= self.total:
                break
            self.total += 1

            symbol = input_stream.read(1)

            exit_flag = False

            # Try encoding in decreasing context order
            for k in reversed(range(len(self.history) + 1)):
                hst = self.history[-k:] if k > 0 else b''

                if hst in self.contexts and self.contexts[hst].get(symbol) is not None:
                    self.update(hst, symbol)
                    exit_flag = True
                    break

                # Encode context escape for this hst
                # Use update() with ESC symbol (not order_minus1) and then increment ESC freq
                # (encoder and decoder must update contexts in same order)
                self.update(hst, ESC)
                self.contexts[hst][ESC] += 1

            # If not found in any context, use order -1 model (uniform 0..255)
            if not exit_flag:
                # symbol is a single byte; pass it as integer via bytes to update for order_minus1
                self.update(b'', symbol, True)

            # Now update all contexts with this symbol and append to history
            self.update_contexts(symbol)
            self.append_to_history(symbol)

        # Final flush: emit one bit to identify final interval and flush queued underflow bits.
        # Standard approach: emit bit based on low relative to QUARTER
        self.bitqueue += 1
        if self.low < QUARTER:
            self.output_bit(False)
        else:
            self.output_bit(True)

        return self.output

    # ========================================================
    # Decoding operations
    # ========================================================

    def read_bit(self):
        """
        Read next bit from self.input_stream (bitarray).
        If beyond end, return 0 (not True) to avoid shifting in a 1.
        """
        if self.index >= len(self.input_stream):
            # return 0 as padding when no more bits are available
            self.index += 1
            return 0
        bit = 1 if self.input_stream[self.index] else 0
        self.index += 1
        return bit

    def updatedec(self, ctx, symbol, order_minus1=False):
        """
        Update ranges for decoding when the decoder already knows the symbol.
        This mirrors update() behaviour.
        """
        if not order_minus1:
            freqs_cum = self.make_cumulative(ctx)
            temp = self.contexts[ctx][symbol]
            total = sum(self.contexts[ctx].values())
            l = freqs_cum.get(symbol, 0)
            h = l + temp
        else:
            temp = 1
            total = 257
            l = symbol[0] if isinstance(symbol, (bytes, bytearray)) else symbol
            h = l + 1

        rng = self.high - self.low + 1

        if total == 0:
            self.high = self.low + rng - 1
        else:
            self.high = self.low + (h * rng) // total - 1
            self.low = self.low + (l * rng) // total

        # renormalize (no bit outputs here; adjust code accordingly)
        while True:
            if self.high < HALF:
                # nothing to do except shift in next bit
                pass

            elif self.low >= HALF:
                self.low -= HALF
                self.high -= HALF

            elif QUARTER <= self.low and self.high < 3 * QUARTER:
                # E3 underflow case
                self.low -= QUARTER
                self.high -= QUARTER
                self.code -= QUARTER

            else:
                break

            # shift and read next bit into code
            self.code = ((self.code << 1) | self.read_bit()) & MAX_RANGE
            self.low = (self.low << 1) & MAX_RANGE
            self.high = ((self.high << 1) | 1) & MAX_RANGE

    def read(self, ctx, order_minus1=False):
        """
        Determine symbol from current code within ctx. Mirrors the encoder's distribution.
        """
        if not order_minus1:
            freqs_cum = self.make_cumulative(ctx)
            total = sum(self.contexts[ctx].values())
        else:
            freqs_cum = None
            total = 257

        rng = self.high - self.low + 1
        offset = self.code - self.low
        value = ((offset + 1) * total - 1) // rng

        # if using freqs_cum (context), iterate in insertion order (same as encoder)
        if not order_minus1:
            # find symbol with largest cumulative <= value
            # freqs_cum is symbol -> cumulative_low
            # create list of (symbol, cumulative_low) in insertion order
            items = list(freqs_cum.items())
            symbol = ESC
            # iterate reversed to find largest cumulative <= value
            for s, cum in reversed(items):
                if value >= cum:
                    symbol = s
                    break
        else:
            # order -1: symbols 0..255 mapped by their index
            # value corresponds to the symbol index
            sym_index = int(value)
            # convert to single byte
            symbol = bytes([sym_index])

        # update ranges and contexts appropriately
        if symbol == ESC:
            # ESC encountered: update using ESC then increment ESC count
            self.updatedec(ctx, ESC, order_minus1)
            self.contexts[ctx][ESC] += 1
        else:
            self.updatedec(ctx, symbol, order_minus1)
            self.update_contexts(symbol)

        return symbol

    def decode_sym(self):
        """
        Try contexts from highest order down to order -1 to decode a symbol.
        """
        for k in reversed(range(len(self.history) + 1)):
            hst = self.history[-k:] if k > 0 else b''
            if hst in self.contexts:
                symbol = self.read(hst)
                if symbol != ESC:
                    return symbol
            else:
                # if context unknown, increment ESC and simulate its consumption
                # (mirror encoder's ESC updates)
                self.contexts[hst][ESC] += 1
                self.updatedec(hst, ESC)
        # if all contexts escape, use order -1
        return self.read(b'', True)

    def decode(self, input_stream_bits, output_stream, length):
        """
        input_stream_bits: bitarray of encoded bits
        output_stream: file-like object to receive decoded bytes (not strictly used here)
        length: number of bytes to decode
        returns: bytes decoded
        """
        self.input_stream = input_stream_bits
        self.index = 0
        self.code = 0

        # Fill initial code with TOTAL_BITS bits (or with available bits padded with zeros)
        for _ in range(TOTAL_BITS):
            self.code = (self.code << 1) | self.read_bit()

        self.contexts = defaultdict(inner_dict)
        self.high = MAX_RANGE
        self.low = 0
        self.total = 0
        self.history = b''
        self.end = False

        out_bytes = b''
        while self.total < length:
            self.total += 1
            symbol = self.decode_sym()
            out_bytes += symbol
            self.append_to_history(symbol)

        return out_bytes

    # ========================================================
    # Context & history management
    # ========================================================

    def update_contexts(self, symbol):
        for k in reversed(range(len(self.history) + 1)):
            hst = self.history[-k:] if k > 0 else b''
            self.contexts[hst][symbol] += 1

    def append_to_history(self, symbol):
        if len(self.history) < self.order:
            self.history += symbol
        else:
            self.history = self.history[1:] + symbol


# ============================================================
# Standalone usage
# ============================================================

if __name__ == "__main__":
    coder = ArithmeticCoder()

    FILE_PATH = "test.txt"
    FILE_PATH_COMPRESS = "compressed.bin"
    FILE_PATH_DECOMPRESS = "vysledek.txt"

    SIZE_NO_OF_BYTES = 4

    # Compression
    with open(FILE_PATH, "rb") as f:
        print(f"Data loaded from {FILE_PATH}.")
        length = os.path.getsize(FILE_PATH)
        encoded_bits = coder.encode(f, length)
        print(f"Encoded {len(encoded_bits)} bits.")
        print(encoded_bits)

    # Write length (number of bytes) and then bit-packed data (full bytes)
    with open(FILE_PATH_COMPRESS, "wb") as f:
        f.write(length.to_bytes(SIZE_NO_OF_BYTES, "big"))
        # write bitarray as bytes (automatically padded to whole bytes)
        encoded_bits.tofile(f)
        
    print(f"Data compressed and saved to {FILE_PATH_COMPRESS}.")

    # Decompression
    bits = bitarray()
    with open(FILE_PATH_COMPRESS, "rb") as f:
        length_b = f.read(SIZE_NO_OF_BYTES)
        length = int.from_bytes(length_b, "big")
        bits.fromfile(f)  # read rest as bits (padding possible)

    print(f"Data loaded from {FILE_PATH_COMPRESS}. Decoding {length} bytes...")
    decoded = coder.decode(bits, None, length)

    with open(FILE_PATH_DECOMPRESS, "wb+") as f:
        f.write(decoded)
    print(f"D